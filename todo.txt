{-

    def uplink_reset_db(self, private_key, public_key):
        """Reset uplink database"""
        address = derive_account_address(public_key)
        r, s = ecdsa_sign(private_key, address)
        signature = pack_signature(r, s)

        params = {
            "method": "ResetDB",
            "params": {
                "address": address,
                "signature": signature
            }
        }

        result = self._call("Test", params=params)
        return result

    def uplink_block(self, block_id):
        block_by_id = 'blocks/{}'.format(block_id)

    def uplink_blocks(self, count=1):
        result = self._call('GET', endpoint='blocks')

    def uplink_peers(self):
        result = self._call('GET', endpoint='peers')

    def uplink_validators(self):
        result = self._call('GET', endpoint='peers/validators')

    def uplink_transactions(self, block_id=0):
        transactions_by_id = 'transactions/{}'.format(block_id)

    def uplink_get_account(self, address):
        account_by_address = 'accounts/{}'.format(address)

    def uplink_get_asset(self, address):
        asset_by_address = 'assets/{}'.format(address)

    def uplink_version(self):
        return self._call('GET', endpoint='version')

    def uplink_contracts(self):
        result = self._call('GET', endpoint='contracts')

    def uplink_get_contract(self, address):
        contract_by_address = 'contracts/{}'.format(address)

    def uplink_get_contract_callable(self, address):
        contract_by_address = 'contracts/{}/callable'.format(address)

    def uplink_get_invalid_transactions(self):
        result = self._call('GET', endpoint='transactions/invalid')

    def uplink_get_mempool(self):
        result = self._call('GET', endpoint='transactions/pool')

    def uplink_get_mempool_size(self):
        result = self._call('GET', endpoint='transactions/pool/size')

    def uplink_get_mempools(self):
        return self._call('GET', endpoint='transactions/pool/all')

    def uplink_get_mempools_sizes(self):
        return self._call('GET', endpoint='transactions/pool/all/sizes')

    def uplink_test_saturate_network(self, n_txs, n_secs):

    def uplink_test_reset_mempools(self):
        params = {
            "method": "ResetMemPools",
            "params": {}
        }

    def uplink_create_account(self, private_key, public_key,
                              from_address=None, metadata=None, timezone=None):
        if timezone is None:
            timezone, localtz = time.tzname

        timestamp = get_time()

        pubkey = public_key.to_string()
        public_key_hex = codecs.encode(pubkey, 'hex')

        acc_address = derive_account_address(public_key)

        hdr = CreateAccountHeader(
            public_key_hex, metadata, acc_address, timezone)
        txb = TxAccount(CreateAccount(hdr))

        r, s = hdr.sign(private_key)
        signature = pack_signature(r, s)

        origin = acc_address if from_address is None else from_address
        tx = Transaction(txb, signature, timestamp,
                         origin=origin)

        params = tx.to_dict()

        result = self._call('Transaction', params=params, endpoint='')

        if self._handle_success(result):
            return Account(timezone, public_key, metadata, acc_address)
        else:
            raise UplinkJsonRpcError("Malformed CreateAccount", result)

    def uplink_create_asset(self, private_key, origin, name,
                            supply, asset_type_nm, reference, issuer,
                            precision=None):
        """Create Asset - returns (result, to_address)"""
        timestamp = get_time()

        hdr = CreateAssetHeader(name, supply, asset_type_nm,
                                reference, issuer, precision, timestamp)
        txb = TxAsset(CreateAsset(hdr))

        r, s = hdr.sign(private_key)
        signature = pack_signature(r, s)

        tx = Transaction(txb, signature, timestamp, origin=origin)
        params = tx.to_dict()

        print(params)

        result = self._call('Transaction', params=params, endpoint='')

        asset_type = AssetType(asset_type_nm, precision)
        asset_addr = derive_asset_address(name, issuer, supply, reference,
                                          asset_type, timestamp)

        if self._handle_success(result):
            return (result, asset_addr)
        else:
            print(result)
            raise UplinkJsonRpcError("Malformed CreateAsset", result)

    def uplink_transfer_asset(self, private_key, from_address, to_address, balance, asset_address):
        timestamp = get_time()

        hdr = TransferAssetHeader(asset_address, to_address, balance)
        txb = TxAsset(Transfer(hdr))

        r, s = hdr.sign(private_key)
        signature = pack_signature(r, s)

        tx = Transaction(txb, signature.decode(), timestamp,
                         origin=from_address)
        params = tx.to_dict()
        result = self._call('Transaction', params=params, endpoint='')
        if self._handle_success(result):
            return result
        else:
            raise UplinkJsonRpcError("Malformed TransferAsset", result)

    def uplink_circulate_asset(self, private_key, from_address, amount, asset_address):
        """Circulate assets"""
        timestamp = get_time()

        hdr = CirculateAssetHeader(asset_address, amount)
        txb = TxAsset(Circulate(hdr))

        r, s = hdr.sign(private_key)
        signature = pack_signature(r, s)

        tx = Transaction(txb, signature.decode(), timestamp,
                         origin=from_address)
        params = tx.to_dict()
        print(params)
        result = self._call('Transaction', params=params, endpoint='')
        if self._handle_success(result):
            return result
        else:
            raise UplinkJsonRpcError("Malformed CirculateAsset", result)

    def uplink_create_contract(self, private_key, from_address, script):
        """Create a new Contract"""
        timestamp = get_time()

        raw_addr = derive_contract_address(timestamp, script)

        hdr = CreateContractHeader(
            script, from_address, raw_addr,
            timestamp, storage=None, methods=None)
        txb = TxContract(CreateContract(hdr))

        r, s = hdr.sign(private_key)
        signature = pack_signature(r, s)

        tx = Transaction(txb, signature, timestamp,
                         origin=from_address)
        params = tx.to_dict()

        result = self._call('Transaction', params=params, endpoint='')
        if self._handle_success(result):
            return result, raw_addr
        else:
            raise UplinkJsonRpcError("create contract error", result)

    def uplink_revoke_asset(self, private_key, from_address, asset_addr):
        """Revoke Asset"""
        timestamp = get_time()

        hdr = RevokeAssetHeader(asset_addr)
        txb = TxAsset(RevokeAsset(hdr))

        r, s = hdr.sign(private_key)
        signature = pack_signature(r, s)

        # to_address=to_address)
        tx = Transaction(txb, signature, timestamp, origin=from_address)
        params = tx.to_dict()

        result = self._call('Transaction', params=params, endpoint='')
        if self._handle_success(result):
            return result
        else:
            raise UplinkJsonRpcError("Malformed RevokeAsset", result)

    def uplink_revoke_account(self, private_key, from_address, account_addr):
        """Revoke account access"""
        timestamp = get_time()

        hdr = RevokeAccountHeader(account_addr)
        txb = TxAccount(RevokeAccount(hdr))

        r, s = hdr.sign(private_key)
        signature = pack_signature(r, s)

        # to_address=to_address)
        tx = Transaction(txb, signature, timestamp, origin=from_address)
        params = tx.to_dict()

        result = self._call('Transaction', params=params, endpoint='')
        if self._handle_success(result):
            return result
        else:
            raise UplinkJsonRpcError("Malformed RevokeAccount", result)

    def uplink_bind_asset(self, private_key, from_address, contract_addr, asset_addr):
        """Bind asset to a contract"""
        timestamp = get_time()

        hdr = BindHeader(contract_addr, asset_addr)
        txb = TxAsset(Bind(hdr))

        r, s = hdr.sign(private_key)
        signature = pack_signature(r, s)

        # XXX Not implemented yet.
        # to_address = derive_contract_address()

        tx = Transaction(txb, signature, timestamp,
                         origin=from_address)  # to_address=to_address)
        params = tx.to_dict()

        result = self._call('Transaction', params=params, endpoint='')

        if self._handle_success(result):
            return result
        else:
            raise UplinkJsonRpcError("Malformed BindAsset", result)

    def uplink_call_contract(self, private_key, from_address, contract_addr, method, args):
        timestamp = get_time()

        hdr = CallHeader(contract_addr, method, args)
        txb = TxContract(Call(hdr))

        r, s = hdr.sign(private_key)
        signature = pack_signature(r, s)

        tx = Transaction(txb, signature, timestamp,
                         origin=from_address)  # to_address=to_address)
        params = tx.to_dict()

        result = self._call('Transaction', params=params, endpoint='')

        if self._handle_success(result):
            return result
        else:
            raise UplinkJsonRpcError("Malformed CallContract", result)

    def uplink_sync_local(self, private_key, from_address, contract_addr):
        timestamp = get_time()

        hdr = SyncHeader(contract_addr)
        txb = TxContract(SyncLocal(hdr))

        r, s = hdr.sign(private_key)
        signature = pack_signature(r, s)

        tx = Transaction(txb, signature, timestamp,
                         origin=from_address)  # to_address=to_address)
        params = tx.to_dict()

        result = self._call('Transaction', params=params, endpoint='')

        if self._handle_success(result):
            return result
        else:
            raise UplinkJsonRpcError("Malformed SyncLocal", result)











127.000.000.001.34592-127.000.000.001.08545: POST / HTTP/1.1
Host: localhost:8545
Connection: keep-alive
Accept-Encoding: gzip, deflate
Accept: */*
User-Agent: python-requests/2.11.1
Content-Length: 664

{"params": {"origin": "7hk8zkaMbcma9LgdsMMzN7EX24QExQmLdrhMsnCE3kvX", "header": {"tag": "TxAsset", "contents": {"tag": "CreateAsset", "contents": {"assetType": {"tag": "Discrete", "contents": null}, "reference": "EUR", "supply": 2, "assetAddr": "2txtGkwvnF1d6LLRoX5gFu3d9GQWtGDXqRAUToeXYw1Q", "assetName": "asdf", "issuer": "7hk8zkaMbcma9LgdsMMzN7EX24QExQmLdrhMsnCE3kvX"}}}, "signature": "AE4xMDMwMTg0NjY4NDg4MDg3NjgzNjQ0OTI4MTI3MTY1OTA2MTE1Njg5NzkxNjk1ODE5OTA0MzAzNDg4NTM0Njg1NTYzNDk1OTcyNzM3ODI6AE0zMDI4Njk4NjkzNTIwNzgyODk0MTA0MTE5NTc1MTU1MTU3NTM1NTUzMTg5NDAyODAyNDM3NDgyMzgzOTExMjA2MjQzNTY1NDIyMzY0OQ==", "timestamp": 1513445589031953}, "method": "Transaction"}

127.000.000.001.08545-127.000.000.001.34592: HTTP/1.1 200 OK
Transfer-Encoding: chunked
Date: Sat, 16 Dec 2017 17:33:09 GMT
Server: Uplink/0.1 (Unix)
Content-Type: application/json; charset=utf-8

0013
{"tag":"RPCRespOK"}
0



-}
RPC Recieved Transaction:
	Transaction {header = TxAsset (CreateAsset {assetAddr = BTp8QQKKmrevr1QJfcUxkHjNspydrcnHiijBLc63miqH, assetName = "asdf", supply = 2, reference = Just USD, assetType = Discrete}), signature = "AE0yMzIwMDY3Njg5NTQ2MDE2NzIzMTA3NDAxODk3MTYwODk0NDQ0ODgzNzMzNDkwMzQ3Mjg0ODE5MjYwMDA5NTEzNzI3NDcwNDY2NjI3ODoATjExMDI2OTI1MTc3ODY5NTIzNzg5ODIzMzQzNzM1NzgyOTE5NjEzMTE4NzgyMTAwNzQ5NjEzMDA2MTc3MTY4MjY2MTA1Nzk2NTM1NTYzNA==", origin = 7hk8zkaMbcma9LgdsMMzN7EX24QExQmLdrhMsnCE3kvX, timestamp = 1513538134596915}

Recieved Cmd from RPC:
	Transaction (Transaction {header = TxAsset (CreateAsset {assetAddr = BTp8QQKKmrevr1QJfcUxkHjNspydrcnHiijBLc63miqH, assetName = "asdf", supply = 2, reference = Just USD, assetType = Discrete}), signature = "AE0yMzIwMDY3Njg5NTQ2MDE2NzIzMTA3NDAxODk3MTYwODk0NDQ0ODgzNzMzNDkwMzQ3Mjg0ODE5MjYwMDA5NTEzNzI3NDcwNDY2NjI3ODoATjExMDI2OTI1MTc3ODY5NTIzNzg5ODIzMzQzNzM1NzgyOTE5NjEzMTE4NzgyMTAwNzQ5NjEzMDA2MTc3MTY4MjY2MTA1Nzk2NTM1NTYzNA==", origin = 7hk8zkaMbcma9LgdsMMzN7EX24QExQmLdrhMsnCE3kvX, timestamp = 1513538134596915})
Requesting peer list from local controller...
127.0.0.1 - - [17/Dec/2017:20:15:34 +0100] "POST / HTTP/1.1" 200 - "" "python-requests/2.11.1"

--

	Transaction {header = TxAsset (CreateAsset {assetAddr = 9MoY2ejwLnJKMQDEaDUKiKXFYf9hMv31EUaf8aYpseAk, assetName = "from explorer", supply = 999, reference = Just CHF, assetType = Discrete}), signature = "AE04NzA0NzIyMDAwMzA2MzAwODE2NjE2MDUxODQzOTExNzk2NTM0MjM2MTUxMjgzMTE3Mzc4NzE0MzEyODQzMjAzODQwOTY2MDM4OTY4MzoATTY1NjY1Nzc1NjA1NzI4NDEyNTU3ODgzNDEzNzQwMzQ3NTA1MDE0MjgwODI1NDI2OTU0OTczNzAyODA5OTU0MzQ5OTMwODM3NzkyMTE5", origin = 7hk8zkaMbcma9LgdsMMzN7EX24QExQmLdrhMsnCE3kvX, timestamp = 1513542677624735}


Transaction {header = TxAsset (CreateAsset {assetAddr = 7hk8zkaMbcma9LgdsMMzN7EX24QExQmLdrhMsnCE3kvX, assetName = "create asset from haskell", supply = 1, reference = Just USD, assetType = Discrete}), signature = "AEw5NDUwMzIxMDk1MTYyNzQxNTQ4NzU0OTY2MjI5ODM1NzgxMTg5NzAyOTE5MDE5Mzk1Njc4OTA4NjY5ODQ4NTA5MTM4ODg5ODUyNzc1OgBOMTEzNjEzMTc5MDcxMjE0MDE5NzY4MzAwMjkwMTU2NDg2OTA1NzA2Mjc2MjcxMDgyMjQ4NjM3MjIzNDU0MDIzNTEyNjQ3OTg1NTYwNjMx", origin = 7hk8zkaMbcma9LgdsMMzN7EX24QExQmLdrhMsnCE3kvX, timestamp = 1513542726013092}


